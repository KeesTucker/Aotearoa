#include "/Engine/Public/Platform.ush"
#include "../FastNoiseLite/FastNoiseLite.usf"

#define E_SHAPE_MODIFIER_SPHERE 0
#define E_SHAPE_MODIFIER_GROUND 1

struct FNoiseLayer
{
	int NoiseType;
	float Scale;
	float Strength;
};

//In
float Seed = 0.0f;
int Resolution = 0;
int ShapeModifier = 0;
int NoiseLayersLength = 0;
StructuredBuffer<FNoiseLayer> NoiseLayers;

//Out
RWStructuredBuffer<float> Output;

[numthreads(THREADS_X, THREADS_Y, THREADS_Z)]
void VoxelDensityComputeShader(
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint GroupIndex : SV_GroupIndex)
{
	const uint Index = DispatchThreadId.x * (Resolution * Resolution)
				 + DispatchThreadId.y * Resolution
				 + DispatchThreadId.z;

	float ShapeDensity = 0.f;
	switch (ShapeModifier)
	{
	case E_SHAPE_MODIFIER_SPHERE:
		{
			const float3 Position = float3(DispatchThreadId.x, DispatchThreadId.y, DispatchThreadId.z);
			const float3 Center = float3(Resolution / 2.f, Resolution / 2.f, Resolution / 2.f);

			// Distance from center
			const float Distance = distance(Position, Center);

			// Normalize
			ShapeDensity = 1.f - Distance / (Resolution / 2.f);

			// Clamp
			ShapeDensity = clamp(ShapeDensity, 0.f, 1.f);
		}
		break;
	case E_SHAPE_MODIFIER_GROUND:
		{
			ShapeDensity = float(Resolution - DispatchThreadId.z) / Resolution;
		}
		break;
	default: ;
	}
	

	float NoiseDensity = 0.f;
	
	for (int i = 0; i < NoiseLayersLength; ++i)
	{
		fnl_state Noise = fnlCreateState();
		Noise.noise_type = NoiseLayers[i].NoiseType;
		NoiseDensity += (fnlGetNoise3D(
			Noise,
			DispatchThreadId.x * NoiseLayers[i].Scale / Resolution + Seed,
			DispatchThreadId.y * NoiseLayers[i].Scale / Resolution + Seed,
			DispatchThreadId.z * NoiseLayers[i].Scale / Resolution + Seed)
			+ 0.5f) * NoiseLayers[i].Strength;
	}
	
	Output[Index] = ShapeDensity  + NoiseDensity;
}