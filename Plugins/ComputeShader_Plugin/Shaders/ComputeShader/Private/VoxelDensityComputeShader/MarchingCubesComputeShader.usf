#include "/Engine/Public/Platform.ush"
#include "MarchingCubesLookupTables.usf"

#define E_SHAPE_MODIFIER_SPHERE 0
#define E_SHAPE_MODIFIER_GROUND 1

struct FTriVerts
{
	float3 A;
	float3 B;
	float3 C;
};

struct FTri
{
	int A;
	int B;
	int C;
};

//In
int Resolution = 0;
float Scale = 0.f;
float IsoLevel = 0.5f;
RWStructuredBuffer<float> Voxels;

//Out
RWStructuredBuffer<FTriVerts> Verts;
RWStructuredBuffer<FTri> Tris;

int VectorIndexToIntIndex(const int3 Coord)
{
	return Coord.x * Resolution * Resolution + Coord.y * Resolution + Coord.z;
}

int3 IntIndexToVectorIndex(const int Index)
{
	float X = Index / (Resolution * Resolution);
	float Y = Index / Resolution % Resolution;
	float Z = Index % Resolution;

	return int3(X, Y, Z);
}

float3 Interp(const float3 EdgeVertex1, const float ValueAtVertex1, const float3 EdgeVertex2, const float ValueAtVertex2)
{
	return EdgeVertex1 + (IsoLevel - ValueAtVertex1) * (EdgeVertex2 - EdgeVertex1)  / (ValueAtVertex2 - ValueAtVertex1);
}

float3 AddVertex(const int Index, const int3 WorldPos, const int Edges[], const int EdgeIndex)
{
	const int E00 = EdgeConnections[Edges[EdgeIndex]][0];
	const int E01 = EdgeConnections[Edges[EdgeIndex]][1];
	const int E00Index = Index + VectorIndexToIntIndex(VertexOffsets[E00]);
	const int E01Index = Index + VectorIndexToIntIndex(VertexOffsets[E01]);
	
	float3 Vert = Interp(
			float3(VertexOffsets[E00]),
			Voxels[E00Index],
			float3(VertexOffsets[E01]),
			Voxels[E01Index]
		) + WorldPos;
	Vert = Vert * Scale;
	return Vert;
}

[numthreads(THREADS_X, THREADS_Y, THREADS_Z)]
void MarchingCubesComputeShader(
	uint3 DispatchThreadId : SV_DispatchThreadID)
{
	if (DispatchThreadId.x == Resolution || DispatchThreadId.y == Resolution || DispatchThreadId.z == Resolution)
		return;
	
	const uint Index = DispatchThreadId.x * (Resolution * Resolution)
				 + DispatchThreadId.y * Resolution
				 + DispatchThreadId.z;

	const int3 VoxelPos = DispatchThreadId;
	
	int CubeIndex = 0;
	for (int i = 0; i < 8; ++i)
	{
		const int CornerPos = Index + VectorIndexToIntIndex(VertexOffsets[i]);
		if (Voxels[CornerPos] < IsoLevel)
			CubeIndex |= int(pow(2, i));
	}

	const int Edges[16] = TriTable[CubeIndex];

	for (int i = 0; Edges[i] != -1; i += 3)
	{
		const float3 ObjectOriginOffset = float3(Resolution / 2.f, Resolution / 2.f, Resolution / 2.f);
		const float3 WorldPos = float3(VoxelPos) - ObjectOriginOffset;
						
		// First edge lies between vertex e00 and vertex e01
		const float3 A = AddVertex(Index, WorldPos, Edges, i);
	
		// Second edge lies between vertex e10 and vertex e11
		const float3 B = AddVertex(Index, WorldPos, Edges, i + 1);
    	    
		// Third edge lies between vertex e20 and vertex e21
		const float3 C = AddVertex(Index, WorldPos, Edges, i + 2);

		FTriVerts TriVerts;
		TriVerts.A = A;
		TriVerts.B = B;
		TriVerts.C = C;

		FTri Tri;
		Tri.A = Index * 15 + i;
		Tri.B = Index * 15 + i + 1;
		Tri.C = Index * 15 + i + 2;
		
		Verts[Index * 5 + i / 3] = TriVerts;
		Tris[Index * 5 + i / 3] = Tri;
	}
}
